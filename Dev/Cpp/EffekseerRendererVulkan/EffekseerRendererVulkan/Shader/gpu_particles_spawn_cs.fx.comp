#version 430
layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

struct Emitter
{
    uint FlagBits;
    uint Seed;
    uint ParticleHead;
    uint ParticleSize;
    uint TrailHead;
    uint TrailSize;
    uint TrailPhase;
    uint NextEmitCount;
    uint TotalEmitCount;
    uint EmitPointCount;
    float TimeCount;
    float TimeStopped;
    uint Reserved0;
    uint Reserved1;
    uint Reserved2;
    uint Color;
    mat4x3 Transform;
};

struct ParameterSet
{
    int EmitCount;
    int EmitPerFrame;
    float EmitOffset;
    uint Padding0;
    vec2 LifeTime;
    uint EmitShapeType;
    uint Padding1;
    vec4 EmitShapeData[2];
    vec3 Direction;
    float Spread;
    vec2 InitialSpeed;
    vec2 Damping;
    vec4 InitialAngleScale[2];
    vec4 TargetAngleScale[2];
    vec3 Gravity;
    uint Padding2;
    vec3 VortexCenter;
    float VortexRotation;
    vec3 VortexAxis;
    float VortexAttraction;
    float TurbulencePower;
    uint TurbulenceSeed;
    float TurbulenceScale;
    float TurbulenceOctave;
    uint RenderState;
    uint ShapeType;
    uint ShapeData;
    float ShapeSize;
    float Emissive;
    float FadeIn;
    float FadeOut;
    uint ColorFlags;
    uvec2 ColorStart;
    uvec2 ColorEnd;
    uint ColorTexIndex;
    uint NormalTexIndex;
    uint TexState;
    uint Padding3;
};

struct EmitPoint
{
    vec3 Position;
    uint Normal;
    uint Binormal;
    uint Tangent;
    uint UV;
    uint VColor;
};

struct Particle
{
    uint FlagBits;
    uint Seed;
    float LifeAge;
    uint InheritColor;
    uvec2 Velocity;
    uint Color;
    uint Padding;
    mat4x3 Transform;
};

struct Constants
{
    vec3 CameraPos;
    float DeltaTime;
    vec3 CameraFront;
    float Reserved;
    mat4 ProjMat;
    mat4 CameraMat;
    mat4x3 BillboardMat;
    mat4x3 YAxisBillboardMat;
};

layout(set = 0, binding = 2, std140) uniform cb2
{
    layout(row_major) Emitter emitter;
} _504;

layout(set = 0, binding = 1, std140) uniform cb1
{
    ParameterSet paramSet;
} _526;

layout(set = 2, binding = 1, std430) readonly buffer EmitPoints
{
    EmitPoint _data[];
} EmitPoints_1;

layout(set = 2, binding = 0, std430) buffer Particles
{
    layout(row_major) Particle _data[];
} Particles_1;

layout(set = 0, binding = 0, std140) uniform cb0
{
    layout(row_major) Constants constants;
} _856;

uint RandomUint(inout uint seed)
{
    uint state = seed;
    seed = (seed * 747796405u) + 2891336453u;
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    return (word >> 22u) ^ word;
}

float RandomFloat(inout uint seed)
{
    uint param = seed;
    uint _317 = RandomUint(param);
    seed = param;
    return float(_317) / 4294967296.0;
}

vec3 RandomSpread(inout uint seed, inout vec3 baseDir, float angle)
{
    uint param = seed;
    float _430 = RandomFloat(param);
    seed = param;
    float theta = 6.28318023681640625 * _430;
    uint param_1 = seed;
    float _437 = RandomFloat(param_1);
    seed = param_1;
    float phi = angle * _437;
    vec3 randDir = vec3(sin(phi) * cos(theta), sin(phi) * sin(theta), cos(phi));
    baseDir = normalize(baseDir);
    if (abs(baseDir.z) != 1.0)
    {
        vec3 front = vec3(0.0, 0.0, 1.0);
        vec3 right = normalize(cross(front, baseDir));
        vec3 up = cross(baseDir, right);
        return mat3(vec3(right), vec3(up), vec3(baseDir)) * randDir;
    }
    else
    {
        return randDir * sign(baseDir.z);
    }
}

float RandomFloatRange(inout uint seed, vec2 maxmin)
{
    uint param = seed;
    float _330 = RandomFloat(param);
    seed = param;
    return mix(maxmin.y, maxmin.x, _330);
}

vec3 RandomDirection(inout uint seed)
{
    uint param = seed;
    float _339 = RandomFloat(param);
    seed = param;
    float theta = 6.28318023681640625 * _339;
    uint param_1 = seed;
    float _345 = RandomFloat(param_1);
    seed = param_1;
    float phi = 6.28318023681640625 * _345;
    vec3 randDir = vec3(sin(phi) * cos(theta), sin(phi) * sin(theta), cos(phi));
    return randDir;
}

vec3 RandomCircle(inout uint seed, inout vec3 axis)
{
    uint param = seed;
    float _368 = RandomFloat(param);
    seed = param;
    float theta = 6.28318023681640625 * _368;
    vec3 randDir = vec3(cos(theta), 0.0, sin(theta));
    axis = normalize(axis);
    if (abs(axis.y) != 1.0)
    {
        vec3 up = vec3(0.0, 1.0, 0.0);
        vec3 right = normalize(cross(up, axis));
        vec3 front = cross(axis, right);
        return mat3(vec3(right), vec3(axis), vec3(front)) * randDir;
    }
    else
    {
        return randDir * sign(axis.y);
    }
}

vec3 UnpackNormalizedFloat3(uint bits)
{
    vec3 v = vec3(uvec3(bits, bits >> uint(10), bits >> uint(20)) & uvec3(1023u));
    return ((v / vec3(1023.0)) * 2.0) - vec3(1.0);
}

mat4x3 TRSMatrix(vec3 translation, vec3 rotation, vec3 scale)
{
    vec3 s = sin(rotation);
    vec3 c = cos(rotation);
    mat4x3 m;
    m[0].x = scale.x * ((c.z * c.y) + ((s.z * s.x) * s.y));
    m[1].x = scale.y * (s.z * c.x);
    m[2].x = scale.z * ((c.z * (-s.y)) + ((s.z * s.x) * c.y));
    m[3].x = translation.x;
    m[0].y = scale.x * (((-s.z) * c.y) + ((c.z * s.x) * s.y));
    m[1].y = scale.y * (c.z * c.x);
    m[2].y = scale.z * (((-s.z) * (-s.y)) + ((c.z * s.x) * c.y));
    m[3].y = translation.y;
    m[0].z = scale.x * (c.x * s.y);
    m[1].z = scale.y * (-s.x);
    m[2].z = scale.z * (c.x * c.y);
    m[3].z = translation.z;
    return m;
}

uvec2 PackFloat4(vec4 v)
{
    uvec4 v16 = uvec4(packHalf2x16(vec2(v.x, 0.0)), packHalf2x16(vec2(v.y, 0.0)), packHalf2x16(vec2(v.z, 0.0)), packHalf2x16(vec2(v.w, 0.0)));
    return uvec2(v16.x | (v16.y << uint(16)), v16.z | (v16.w << uint(16)));
}

uvec2 PackFloat4(vec3 v3, float v1)
{
    vec4 param = vec4(v3, v1);
    return PackFloat4(param);
}

void _main(uvec3 dtid)
{
    uint seed = _504.emitter.Seed ^ (_504.emitter.TotalEmitCount + dtid.x);
    vec3 position = _504.emitter.Transform[3];
    uint param = seed;
    vec3 param_1 = _526.paramSet.Direction;
    float param_2 = (_526.paramSet.Spread * 3.1415920257568359375) / 180.0;
    vec3 _541 = RandomSpread(param, param_1, param_2);
    seed = param;
    vec3 direction = _541;
    uint param_3 = seed;
    vec2 param_4 = _526.paramSet.InitialSpeed;
    float _550 = RandomFloatRange(param_3, param_4);
    seed = param_3;
    float speed = _550;
    if (_526.paramSet.EmitShapeType == 1u)
    {
        vec3 lineStart = _504.emitter.Transform * vec4(_526.paramSet.EmitShapeData[0].xyz, 0.0);
        vec3 lineEnd = _504.emitter.Transform * vec4(_526.paramSet.EmitShapeData[1].xyz, 0.0);
        float lineWidth = _526.paramSet.EmitShapeData[1].w;
        uint param_5 = seed;
        float _590 = RandomFloat(param_5);
        seed = param_5;
        position += mix(lineStart, lineEnd, vec3(_590));
        uint param_6 = seed;
        vec3 _598 = RandomDirection(param_6);
        seed = param_6;
        position += ((_598 * lineWidth) * 0.5);
    }
    else
    {
        if (_526.paramSet.EmitShapeType == 2u)
        {
            vec3 circleAxis = _504.emitter.Transform * vec4(_526.paramSet.EmitShapeData[0].xyz, 0.0);
            float circleInner = _526.paramSet.EmitShapeData[1].x;
            float circleOuter = _526.paramSet.EmitShapeData[1].y;
            uint param_7 = seed;
            float _634 = RandomFloat(param_7);
            seed = param_7;
            float circleRadius = mix(circleInner, circleOuter, _634);
            uint param_8 = seed;
            vec3 param_9 = circleAxis;
            vec3 _641 = RandomCircle(param_8, param_9);
            seed = param_8;
            position += (_641 * circleRadius);
        }
        else
        {
            if (_526.paramSet.EmitShapeType == 3u)
            {
                float sphereRadius = _526.paramSet.EmitShapeData[0].x;
                uint param_10 = seed;
                vec3 _658 = RandomDirection(param_10);
                seed = param_10;
                position += (_658 * sphereRadius);
            }
            else
            {
                if (_526.paramSet.EmitShapeType == 4u)
                {
                    float modelSize = _526.paramSet.EmitShapeData[0].y;
                    if (_504.emitter.EmitPointCount > 0u)
                    {
                        uint param_11 = seed;
                        uint _681 = RandomUint(param_11);
                        seed = param_11;
                        uint emitIndex = _681 % _504.emitter.EmitPointCount;
                        EmitPoint emitPoint;
                        emitPoint.Position = EmitPoints_1._data[emitIndex].Position;
                        emitPoint.Normal = EmitPoints_1._data[emitIndex].Normal;
                        emitPoint.Binormal = EmitPoints_1._data[emitIndex].Binormal;
                        emitPoint.Tangent = EmitPoints_1._data[emitIndex].Tangent;
                        emitPoint.UV = EmitPoints_1._data[emitIndex].UV;
                        emitPoint.VColor = EmitPoints_1._data[emitIndex].VColor;
                        position += (_504.emitter.Transform * vec4(emitPoint.Position * modelSize, 0.0));
                        uint param_12 = emitPoint.Normal;
                        vec3 emitNormal = UnpackNormalizedFloat3(param_12);
                        uint param_13 = emitPoint.Binormal;
                        vec3 emitBinormal = UnpackNormalizedFloat3(param_13);
                        uint param_14 = emitPoint.Tangent;
                        vec3 emitTangent = UnpackNormalizedFloat3(param_14);
                        direction = mat3(vec3(normalize(emitTangent)), vec3(normalize(emitBinormal)), vec3(normalize(emitNormal))) * direction;
                    }
                }
            }
        }
    }
    direction = _504.emitter.Transform * vec4(direction, 0.0);
    uint particleID = _504.emitter.ParticleHead + ((_504.emitter.TotalEmitCount + dtid.x) % _504.emitter.ParticleSize);
    Particle particle;
    particle.FlagBits = 1u;
    particle.Seed = seed;
    particle.LifeAge = 0.0;
    if (_526.paramSet.ColorFlags == 0u)
    {
        particle.InheritColor = 4294967295u;
    }
    else
    {
        particle.InheritColor = _504.emitter.Color;
    }
    particle.Color = 4294967295u;
    particle.Padding = 0u;
    vec3 param_15 = position;
    vec3 param_16 = vec3(0.0);
    vec3 param_17 = vec3(1.0);
    particle.Transform = TRSMatrix(param_15, param_16, param_17);
    vec3 param_18 = direction * speed;
    float param_19 = 0.0;
    particle.Velocity = PackFloat4(param_18, param_19);
    Particles_1._data[particleID].FlagBits = particle.FlagBits;
    Particles_1._data[particleID].Seed = particle.Seed;
    Particles_1._data[particleID].LifeAge = particle.LifeAge;
    Particles_1._data[particleID].InheritColor = particle.InheritColor;
    Particles_1._data[particleID].Velocity = particle.Velocity;
    Particles_1._data[particleID].Color = particle.Color;
    Particles_1._data[particleID].Padding = particle.Padding;
    Particles_1._data[particleID].Transform = particle.Transform;
}

void main()
{
    uvec3 dtid = gl_GlobalInvocationID;
    uvec3 param = dtid;
    _main(param);
}

