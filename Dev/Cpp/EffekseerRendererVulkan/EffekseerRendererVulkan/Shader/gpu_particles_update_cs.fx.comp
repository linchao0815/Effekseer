#version 430
layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

struct Emitter
{
    uint FlagBits;
    uint Seed;
    uint ParticleHead;
    uint ParticleSize;
    uint TrailHead;
    uint TrailSize;
    uint TrailPhase;
    uint NextEmitCount;
    uint TotalEmitCount;
    uint EmitPointCount;
    float TimeCount;
    float TimeStopped;
    uint Reserved0;
    uint Reserved1;
    uint Reserved2;
    uint Color;
    mat4x3 Transform;
};

struct Particle
{
    uint FlagBits;
    uint Seed;
    float LifeAge;
    uint InheritColor;
    uvec2 Velocity;
    uint Color;
    uint Padding;
    mat4x3 Transform;
};

struct Constants
{
    vec3 CameraPos;
    float DeltaTime;
    vec3 CameraFront;
    float Reserved;
    mat4 ProjMat;
    mat4 CameraMat;
    mat4x3 BillboardMat;
    mat4x3 YAxisBillboardMat;
};

struct ParameterSet
{
    int EmitCount;
    int EmitPerFrame;
    float EmitOffset;
    uint Padding0;
    vec2 LifeTime;
    uint EmitShapeType;
    uint Padding1;
    vec4 EmitShapeData[2];
    vec3 Direction;
    float Spread;
    vec2 InitialSpeed;
    vec2 Damping;
    vec4 InitialAngleScale[2];
    vec4 TargetAngleScale[2];
    vec3 Gravity;
    uint Padding2;
    vec3 VortexCenter;
    float VortexRotation;
    vec3 VortexAxis;
    float VortexAttraction;
    float TurbulencePower;
    uint TurbulenceSeed;
    float TurbulenceScale;
    float TurbulenceOctave;
    uint RenderState;
    uint ShapeType;
    uint ShapeData;
    float ShapeSize;
    float Emissive;
    float FadeIn;
    float FadeOut;
    uint ColorFlags;
    uvec2 ColorStart;
    uvec2 ColorEnd;
    uint ColorTexIndex;
    uint NormalTexIndex;
    uint TexState;
    uint Padding3;
};

struct Trail
{
    vec3 Position;
    uint Direction;
};

layout(set = 0, binding = 2, std140) uniform cb2
{
    layout(row_major) Emitter emitter;
} _540;

layout(set = 2, binding = 0, std430) buffer Particles
{
    layout(row_major) Particle _data[];
} Particles_1;

layout(set = 0, binding = 0, std140) uniform cb0
{
    layout(row_major) Constants constants;
} _595;

layout(set = 0, binding = 1, std140) uniform cb1
{
    ParameterSet paramSet;
} _609;

layout(set = 2, binding = 1, std430) buffer Trails
{
    Trail _data[];
} Trails_1;

layout(set = 1, binding = 2) uniform sampler3D Sampler_NoiseVFSamp;

uint RandomUint(inout uint seed)
{
    uint state = seed;
    seed = (seed * 747796405u) + 2891336453u;
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    return (word >> 22u) ^ word;
}

float RandomFloat(inout uint seed)
{
    uint param = seed;
    uint _443 = RandomUint(param);
    seed = param;
    return float(_443) / 4294967296.0;
}

float RandomFloatRange(inout uint seed, vec2 maxmin)
{
    uint param = seed;
    float _456 = RandomFloat(param);
    seed = param;
    return mix(maxmin.y, maxmin.x, _456);
}

vec4 RandomFloat4Range(inout uint seed, vec4 maxmin[2])
{
    uint param = seed;
    float _467 = RandomFloat(param);
    seed = param;
    return mix(maxmin[1], maxmin[0], vec4(_467));
}

vec4 UnpackColor(uint color32)
{
    return vec4(float(color32 & 255u), float((color32 >> uint(8)) & 255u), float((color32 >> uint(16)) & 255u), float((color32 >> uint(24)) & 255u)) / vec4(255.0);
}

vec4 RandomColorRange(inout uint seed, uvec2 maxmin)
{
    uint param = maxmin.y;
    uint param_1 = maxmin.x;
    uint param_2 = seed;
    float _483 = RandomFloat(param_2);
    seed = param_2;
    return mix(UnpackColor(param), UnpackColor(param_1), vec4(_483));
}

vec4 UnpackFloat4(uvec2 bits)
{
    return vec4(unpackHalf2x16(uvec4(bits.x, bits.x >> uint(16), bits.y, bits.y >> uint(16)).x).x, unpackHalf2x16(uvec4(bits.x, bits.x >> uint(16), bits.y, bits.y >> uint(16)).y).x, unpackHalf2x16(uvec4(bits.x, bits.x >> uint(16), bits.y, bits.y >> uint(16)).z).x, unpackHalf2x16(uvec4(bits.x, bits.x >> uint(16), bits.y, bits.y >> uint(16)).w).x);
}

uint PackNormalizedFloat3(vec3 v)
{
    uvec3 i = uvec3(((v + vec3(1.0)) * 0.5) * 1023.0);
    return (i.x | (i.y << uint(10))) | (i.z << uint(20));
}

vec3 Vortex(float rotation, float attraction, inout vec3 center, inout vec3 axis, vec3 position, mat4x3 transform)
{
    center = transform[3] + center;
    axis = normalize(transform * vec4(axis, 0.0));
    vec3 diff = position - center;
    float _distance = length(diff);
    if (_distance == 0.0)
    {
        return vec3(0.0);
    }
    vec3 radial = diff / vec3(_distance);
    vec3 tangent = cross(axis, radial);
    radial = cross(tangent, axis);
    return (tangent * rotation) - (radial * attraction);
}

mat4x3 TRSMatrix(vec3 translation, vec3 rotation, vec3 scale)
{
    vec3 s = sin(rotation);
    vec3 c = cos(rotation);
    mat4x3 m;
    m[0].x = scale.x * ((c.z * c.y) + ((s.z * s.x) * s.y));
    m[1].x = scale.y * (s.z * c.x);
    m[2].x = scale.z * ((c.z * (-s.y)) + ((s.z * s.x) * c.y));
    m[3].x = translation.x;
    m[0].y = scale.x * (((-s.z) * c.y) + ((c.z * s.x) * s.y));
    m[1].y = scale.y * (c.z * c.x);
    m[2].y = scale.z * (((-s.z) * (-s.y)) + ((c.z * s.x) * c.y));
    m[3].y = translation.y;
    m[0].z = scale.x * (c.x * s.y);
    m[1].z = scale.y * (-s.x);
    m[2].z = scale.z * (c.x * c.y);
    m[3].z = translation.z;
    return m;
}

uvec2 PackFloat4(vec4 v)
{
    uvec4 v16 = uvec4(packHalf2x16(vec2(v.x, 0.0)), packHalf2x16(vec2(v.y, 0.0)), packHalf2x16(vec2(v.z, 0.0)), packHalf2x16(vec2(v.w, 0.0)));
    return uvec2(v16.x | (v16.y << uint(16)), v16.z | (v16.w << uint(16)));
}

uvec2 PackFloat4(vec3 v3, float v1)
{
    vec4 param = vec4(v3, v1);
    return PackFloat4(param);
}

uint PackColor(vec4 color)
{
    uvec4 colori = uvec4(clamp(color * 255.0, vec4(0.0), vec4(255.0)));
    return ((colori.x | (colori.y << uint(8))) | (colori.z << uint(16))) | (colori.w << uint(24));
}

void _main(uvec3 dtid)
{
    uint particleID = _540.emitter.ParticleHead + dtid.x;
    Particle particle;
    particle.FlagBits = Particles_1._data[particleID].FlagBits;
    particle.Seed = Particles_1._data[particleID].Seed;
    particle.LifeAge = Particles_1._data[particleID].LifeAge;
    particle.InheritColor = Particles_1._data[particleID].InheritColor;
    particle.Velocity = Particles_1._data[particleID].Velocity;
    particle.Color = Particles_1._data[particleID].Color;
    particle.Padding = Particles_1._data[particleID].Padding;
    particle.Transform = Particles_1._data[particleID].Transform;
    if ((particle.FlagBits & 1u) != 0u)
    {
        uint updateCount = (particle.FlagBits >> uint(1)) & 255u;
        float deltaTime = _595.constants.DeltaTime;
        uint seed = particle.Seed;
        uint param = seed;
        vec2 param_1 = _609.paramSet.LifeTime;
        float _616 = RandomFloatRange(param, param_1);
        seed = param;
        float lifeTime = _616;
        float lifeRatio = particle.LifeAge / lifeTime;
        uint param_2 = seed;
        vec2 param_3 = _609.paramSet.Damping;
        float _630 = RandomFloatRange(param_2, param_3);
        seed = param_2;
        float damping = _630 * 0.00999999977648258209228515625;
        uint param_4 = seed;
        vec4 param_5[2];
        param_5[0] = _609.paramSet.InitialAngleScale[0];
        param_5[1] = _609.paramSet.InitialAngleScale[1];
        vec4 _646 = RandomFloat4Range(param_4, param_5);
        seed = param_4;
        vec4 initialAngleScale = _646;
        uint param_6 = seed;
        vec4 param_7[2];
        param_7[0] = _609.paramSet.TargetAngleScale[0];
        param_7[1] = _609.paramSet.TargetAngleScale[1];
        vec4 _660 = RandomFloat4Range(param_6, param_7);
        seed = param_6;
        vec4 targetAngleScale = _660;
        vec3 initialAngle = initialAngleScale.xyz;
        vec3 angularVelocity = targetAngleScale.xyz;
        float initialScale = initialAngleScale.w;
        float terminalScale = targetAngleScale.w;
        uint param_8 = seed;
        uvec2 param_9 = _609.paramSet.ColorStart;
        vec4 _682 = RandomColorRange(param_8, param_9);
        seed = param_8;
        vec4 colorStart = _682;
        uint param_10 = seed;
        uvec2 param_11 = _609.paramSet.ColorEnd;
        vec4 _691 = RandomColorRange(param_10, param_11);
        seed = param_10;
        vec4 colorEnd = _691;
        vec3 position = particle.Transform[3];
        uvec2 param_12 = particle.Velocity;
        vec3 velocity = UnpackFloat4(param_12).xyz;
        if (_540.emitter.TrailSize > 0u)
        {
            uint trailID = (_540.emitter.TrailHead + (dtid.x * _609.paramSet.ShapeData)) + _540.emitter.TrailPhase;
            Trail trail;
            trail.Position = position;
            vec3 param_13 = velocity;
            trail.Direction = PackNormalizedFloat3(param_13);
            Trails_1._data[trailID].Position = trail.Position;
            Trails_1._data[trailID].Direction = trail.Direction;
        }
        particle.FlagBits &= 4294966785u;
        particle.FlagBits |= (clamp(updateCount + 1u, 0u, 255u) << uint(1));
        particle.LifeAge += _595.constants.DeltaTime;
        if (particle.LifeAge >= lifeTime)
        {
            particle.FlagBits &= 4294967294u;
        }
        velocity += (_609.paramSet.Gravity * deltaTime);
        if ((_609.paramSet.VortexRotation != 0.0) || (_609.paramSet.VortexAttraction != 0.0))
        {
            float param_14 = _609.paramSet.VortexRotation;
            float param_15 = _609.paramSet.VortexAttraction;
            vec3 param_16 = _609.paramSet.VortexCenter;
            vec3 param_17 = _609.paramSet.VortexAxis;
            vec3 param_18 = position;
            mat4x3 param_19 = _540.emitter.Transform;
            vec3 _810 = Vortex(param_14, param_15, param_16, param_17, param_18, param_19);
            velocity += (_810 * deltaTime);
        }
        if (_609.paramSet.TurbulencePower != 0.0)
        {
            vec4 vfTexel = textureLod(Sampler_NoiseVFSamp, (position / vec3(8.0)) + vec3(0.5), 0.0);
            velocity += ((((vfTexel.xyz * 2.0) - vec3(1.0)) * _609.paramSet.TurbulencePower) * deltaTime);
        }
        float speed = length(velocity);
        if (speed > 0.0)
        {
            float newSpeed = max(0.0, speed - (damping * deltaTime));
            velocity *= (newSpeed / speed);
        }
        position += (velocity * _595.constants.DeltaTime);
        vec3 rotation = initialAngle + (angularVelocity * particle.LifeAge);
        float scale = mix(initialScale, terminalScale, lifeRatio) * _609.paramSet.ShapeSize;
        vec4 color = mix(colorStart, colorEnd, vec4(lifeRatio));
        if ((_609.paramSet.ColorFlags == 2u) || (_609.paramSet.ColorFlags == 3u))
        {
            uint param_20 = _540.emitter.Color;
            color *= UnpackColor(param_20);
        }
        else
        {
            uint param_21 = particle.InheritColor;
            color *= UnpackColor(param_21);
        }
        color.w *= clamp(particle.LifeAge / _609.paramSet.FadeIn, 0.0, 1.0);
        color.w *= clamp((lifeTime - particle.LifeAge) / _609.paramSet.FadeOut, 0.0, 1.0);
        vec3 param_22 = position;
        vec3 param_23 = rotation;
        vec3 param_24 = vec3(scale, scale, scale);
        particle.Transform = TRSMatrix(param_22, param_23, param_24);
        vec3 param_25 = velocity;
        float param_26 = 0.0;
        particle.Velocity = PackFloat4(param_25, param_26);
        vec4 param_27 = color;
        particle.Color = PackColor(param_27);
        Particles_1._data[particleID].FlagBits = particle.FlagBits;
        Particles_1._data[particleID].Seed = particle.Seed;
        Particles_1._data[particleID].LifeAge = particle.LifeAge;
        Particles_1._data[particleID].InheritColor = particle.InheritColor;
        Particles_1._data[particleID].Velocity = particle.Velocity;
        Particles_1._data[particleID].Color = particle.Color;
        Particles_1._data[particleID].Padding = particle.Padding;
        Particles_1._data[particleID].Transform = particle.Transform;
    }
}

void main()
{
    uvec3 dtid = gl_GlobalInvocationID;
    uvec3 param = dtid;
    _main(param);
}

